<!-- author: Bruno Pitteli Gonçalves (scorninpc) -->
<!-- código usado para aprender sobre primeiros passos para desenvolvimento de jogos -->

<!-- jogo breakout do atari -->

<!-- referencias -->
<!-- https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript -->
<!-- https://freesound.org/people/qubodup/sounds/757612/ -->
<!-- https://freesound.org/people/qubodup/sounds/463391/ -->
<!-- https://freesound.org/people/aleixcm/sounds/233496/ -->
<!-- https://pixabay.com/sound-effects/ui-build-finish-398858/ -->

<html lang="pt-br">
	<head>
		<meta charset="utf-8" />
		<title>Gamedev Canvas Workshop</title>

		<style>
			* {
				padding: 0;
				margin: 0;
			}
			canvas {
				background: #eeeeee;
			}
			button {
				margin-top: 20px;
				display: block;
			}
		</style>
	</head>
	<body>
		<canvas id="myCanvas" width="480" height="320"></canvas>
		<button id="runButton">Start game</button>

		<audio  id="audHitBrick" preload="auto">
			<source src="757612__qubodup__pop-sound.ogg" type="audio/ogg">
			<source src="757612__qubodup__pop-sound.mp3" type="audio/mpeg">
		</audio>
		<audio  id="audHitPaddle" preload="auto">
			<source src="463391__vilkas_sound__vs-pop_1.ogg" type="audio/ogg">
			<source src="463391__vilkas_sound__vs-pop_1.mp3" type="audio/mpeg">
		</audio>
		<audio  id="audLose" preload="auto">
			<source src="ui-build-finish-398858.ogg" type="audio/ogg">
			<source src="ui-build-finish-398858.mp3" type="audio/mpeg">
		</audio>
		<audio  id="audWin" preload="auto">
			<source src="233496__aleixcm__microwave_bell.ogg" type="audio/ogg">
			<source src="233496__aleixcm__microwave_bell.mp3" type="audio/mpeg">
		</audio>

		<script>
			// inicializa os audios
			const audHitBrick = document.getElementById("audHitBrick");
			const audHitPaddle = document.getElementById("audHitPaddle");
			const audLose = document.getElementById("audLose");
			const audWin = document.getElementById("audWin");

			// inicializa o canvas
			const canvas = document.getElementById("myCanvas");
			const ctx = canvas.getContext("2d");

			// controle do jogo
			let interval = 0;
			let finalizado = false;
			let score = 0;
			let lives = 3;
			let level = 1;

			// variaveis da barra
			const paddleHeight = 10;
			const paddleWidth = 75;
			let paddleX = (canvas.width - paddleWidth) / 2;
			let rightPressed = false;
			let leftPressed = false;

			// variaveis da bolinha
			let x = canvas.width / 2;
			let y = canvas.height - 30;

			const ballRadius = 10;

			let dx = 2;
			let dy = -2;

			// variaveis dos tijolinhos
			const brickRowCount = 3;
			const brickColumnCount = 5;
			const brickWidth = 75;
			const brickHeight = 20;
			const brickPadding = 10;
			const brickOffsetTop = 30;
			const brickOffsetLeft = 30;
			const bricks = [];
			let bricksLeft = 0;
			function createBricks()
			{
				bricksLeft = 0;
				for (let c = 0; c < brickColumnCount; c++) {
					bricks[c] = [];
					for (let r = 0; r < brickRowCount; r++) {
						bricks[c][r] = { x: 0, y: 0, status: 1 };
						bricksLeft++;
					}
				}
			}
			createBricks();

			// desenha a bolinha
			function drawBall() {
				ctx.beginPath();
				ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
				ctx.fillStyle = "#0095DD";
				ctx.fill();
				ctx.closePath();
			}

			// desenha a barra
			function drawPaddle() {
				ctx.beginPath();
				ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
				ctx.fillStyle = "#0095DD";
				ctx.fill();
				ctx.closePath();
			}
	
			// desenha os tijolinhos
			function drawBricks() {
				for (let c = 0; c < brickColumnCount; c++) {
					for (let r = 0; r < brickRowCount; r++) {
						if (bricks[c][r].status === 1) {
							const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
							const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;

							bricks[c][r].x = brickX;
							bricks[c][r].y = brickY;
							ctx.beginPath();
							ctx.rect(brickX, brickY, brickWidth, brickHeight);
							ctx.fillStyle = "#0095DD";
							ctx.fill();
							ctx.closePath();
						}
					}
				}
			}

			// desenha o score
			function drawScore() {
				ctx.font = "14px Arial";
				ctx.fillStyle = "#0095DD";
				ctx.fillText(`Lives: ${lives} / Level: ${level} / Score: ${score}`, 8, 20);
			}

			// detecta a coalisão da bolinha com o tijolinho 
			function collisionDetection() {
				for (let c = 0; c < brickColumnCount; c++) {
					for (let r = 0; r < brickRowCount; r++) {

						// tijolinho testado
						const b = bricks[c][r];
						if (b.status === 1) {
							// se o centro da bolinha > que o X do tijolinho, < que o X - width
							// se o centro da bolinha > que o Y do tijolinho, < que o Y - HEIGHT
							// ou seja, se o centro da bolinha estão DENTRO do tijolinho
							if ((x > b.x) && (x < b.x + brickWidth) && (y > b.y) && (y < b.y + brickHeight)) {
								dy = -dy;
								b.status = 0;
								score++;
								bricksLeft--;

								// toca o hit
								audHitBrick.currentTime = 0;
								audHitBrick.play();

								// quando acabar os blocos, mostra o win
								if(bricksLeft == 0) {
									// clearInterval(interval); // aqui nao ta limpando o ultimo bloco e resentando

									audWin.currentTime = 0;
									audWin.play();

									level++;

									resetLevel();
								}
							}
						}
					}
				}
			}

			// loop principal
			function draw() {

				ctx.clearRect(0, 0, canvas.width, canvas.height);
				
				// faz os desenhos
				drawBall();
				drawPaddle();
				drawBricks();
				drawScore();

				// calcula a posição da bolinha
				x += dx;
				y += dy;

				// coalisão TOP (se a bolinha + movimento for MENOR que 0, fora da tela)
				// ao invez de 0, usamos ballRadius, pois não queremos o HIT no meio da bola, mais sim quando a bola encostar
				// agora ela só colide com o TOP, pois se fizer a coalisão com BOTTOM é porque deu gameover
				if((y + dy) < ballRadius) {
					dy = -dy;
				}
				else if((y + dy) > (canvas.height - ballRadius - paddleHeight)) {

					// se está colidindo com a barra
					// algumas situações ele hita a barra menos ou mais que o centro da bolinha, então calcula 1/3 da bolinha,que é X (meio) - ballRadius/2
					if ((((x + ballRadius/2) > paddleX) && ((x - ballRadius/2) < paddleX + paddleWidth)) && !(finalizado)) {
						dy = -dy;

						// toca o hit
						audHitPaddle.currentTime = 0;
						audHitPaddle.play();
					}
					else {
						// game over
						finalizado = true;

						// ja deu gameover, mais deixa a animação da bolinha sair completamente da tela para finalizar o jogo
						if(y > canvas.height + ballRadius) {
							lives--;

							audLose.currentTime = 0;
							audLose.play();

							if(lives <= 0) {
								clearInterval(interval);

								console.log("GAMEOVER");
								runButton.disabled = false;
							}
							else {
								finalizado = false;

								x = canvas.width / 2;
								y = canvas.height - 30;

								dx = velocidade();
								dy = velocidade() * -1;

								paddleX = (canvas.width - paddleWidth) / 2;

								rightPressed = false;
								leftPressed = false;
							}
						}
					}
				}

				// coalisão LEFT (se a bolinha + movimento for MENOR que a tela de lado, fora da tela)
				// ao invez de 0, usamos ballRadius, pois não queremos o HIT no meio da bola, mais sim quando a bola encostar
				if((x + dx < ballRadius) || (x + dx > canvas.width - ballRadius)) {
					dx = -dx;
				}

				// se ja está finalizado nao faz mais nada, só desenha a bolinha mesmo
				if((finalizado)) {
					return;
				}


				// move e desenha a barrinha
				if(rightPressed) {
					paddleX = Math.min(paddleX + 7, canvas.width - paddleWidth);
				}
				else if(leftPressed) {
					paddleX = Math.max(paddleX - 7, 0);
				}
				
				// calcula a coalisão com algum tijolinho
				collisionDetection();
			}

			// função que inicia o jogo
			function startGame() {
				
				resetGame();

				interval = setInterval(draw, 10);
			}

			// reseta o game
			function resetGame() {
				level = 1;
				score = 0;
				lives = 3;

				finalizado = false;

				resetLevel();
			}

			// reseta o level
			function resetLevel()
			{
				createBricks();

				x = canvas.width / 2;
				y = canvas.height - 30;

				dx = velocidade();
				dy = velocidade() * -1;

				paddleX = (canvas.width - paddleWidth) / 2;

				rightPressed = false;
				leftPressed = false;
			}

			function velocidade() {
				return 2 + ((4 - 2) / 15) * level;
			}

			// botão para iniciar o jogo
			const runButton = document.getElementById("runButton");
			runButton.addEventListener("click", () => {
				startGame();
				runButton.disabled = true;
			});

			// evento de pressionar e soltar os botões do teclado
			document.addEventListener("keydown", keyDownHandler);
			document.addEventListener("keyup", keyUpHandler);
			function keyDownHandler(e) {
				if (e.key === "Right" || e.key === "ArrowRight" || e.key === "d") {
					rightPressed = true;
				} else if (e.key === "Left" || e.key === "ArrowLeft" || e.key === "a") {
					leftPressed = true;
				}
			}
			function keyUpHandler(e) {
				if (e.key === "Right" || e.key === "ArrowRight" || e.key === "d") {
					rightPressed = false;
				} else if (e.key === "Left" || e.key === "ArrowLeft" || e.key === "a") {
					leftPressed = false;
				}
			}

			// adiciona evento ao mover o mouse
			document.addEventListener("mousemove", mouseMoveHandler);
			function mouseMoveHandler(e) {
				const relativeX = e.clientX - canvas.offsetLeft;
				if(relativeX > 0 && relativeX < canvas.width) {
					
					paddleX = relativeX - paddleWidth / 2;

					paddleX = Math.min(paddleX, canvas.width - paddleWidth);
					paddleX = Math.max(paddleX, 0);
				}
			}


		</script>
		
	</body>
</html>